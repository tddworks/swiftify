package io.swiftify.gradle

import io.swiftify.linker.*
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import java.io.File

/**
 * Task that processes a Kotlin/Native framework and injects Swiftify extensions.
 *
 * This task runs after the framework is built and:
 * 1. Reads the Swiftify manifest generated by KSP
 * 2. Generates Swift code based on the manifest
 * 3. Injects the Swift code into the framework
 */
abstract class SwiftifyLinkTask : DefaultTask() {

    /**
     * The framework directory to process.
     */
    @get:InputDirectory
    abstract val frameworkDirectory: DirectoryProperty

    /**
     * The manifest file generated by KSP.
     */
    @get:InputFile
    @get:Optional
    abstract val manifestFile: RegularFileProperty

    /**
     * Output directory for generated Swift files.
     */
    @get:OutputDirectory
    abstract val outputDirectory: DirectoryProperty

    /**
     * Whether to compile Swift code (requires Xcode/Swift toolchain).
     */
    @get:Input
    @get:Optional
    abstract val compileSwift: Property<Boolean>

    /**
     * Target triple for Swift compilation.
     */
    @get:Input
    @get:Optional
    abstract val targetTriple: Property<String>

    /**
     * SDK path for Swift compilation.
     */
    @get:Input
    @get:Optional
    abstract val sdkPath: Property<String>

    init {
        group = "swiftify"
        description = "Inject Swiftify extensions into framework"
        compileSwift.convention(false)
    }

    @TaskAction
    fun link() {
        val frameworkDir = frameworkDirectory.get().asFile
        if (!frameworkDir.exists()) {
            logger.lifecycle("Swiftify: Framework not found at ${frameworkDir.absolutePath}")
            return
        }

        val manifest = manifestFile.orNull?.asFile
        if (manifest == null || !manifest.exists()) {
            logger.lifecycle("Swiftify: No manifest found, skipping link phase")
            return
        }

        logger.lifecycle("Swiftify: Processing framework ${frameworkDir.name}")

        val linkerConfig = SwiftifyLinkerConfig(
            compileSwift = compileSwift.getOrElse(false),
            targetTriple = targetTriple.orNull,
            sdkPath = sdkPath.orNull,
            dryRun = false,
            logger = { msg -> logger.lifecycle("Swiftify: $msg") },
        )

        val processorConfig = FrameworkProcessorConfig(linkerConfig)
        val processor = FrameworkProcessor(processorConfig)

        val result = processor.process(frameworkDir, manifest)

        when (result) {
            is ProcessingResult.Success -> {
                logger.lifecycle("Swiftify: ${result.message}")
            }
            is ProcessingResult.Error -> {
                throw org.gradle.api.GradleException("Swiftify: ${result.message}")
            }
        }

        // Copy Swift files to output directory
        val swiftifyDir = File(frameworkDir, "Swiftify")
        if (swiftifyDir.exists()) {
            val outputDir = outputDirectory.get().asFile
            outputDir.mkdirs()
            swiftifyDir.listFiles()?.forEach { file ->
                file.copyTo(File(outputDir, file.name), overwrite = true)
            }
        }
    }
}
