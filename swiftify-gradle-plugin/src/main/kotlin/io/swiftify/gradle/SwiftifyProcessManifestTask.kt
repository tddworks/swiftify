package io.swiftify.gradle

import io.swiftify.generator.SwiftAsyncStreamGenerator
import io.swiftify.generator.SwiftDefaultsGenerator
import io.swiftify.generator.SwiftEnumGenerator
import io.swiftify.swift.*
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.provider.ListProperty
import org.gradle.api.tasks.*
import java.io.File

/**
 * Task that processes the KSP-generated manifest and produces Swift code.
 *
 * This task is used in KSP analysis mode. It reads the manifest file produced
 * by SwiftifySymbolProcessor and generates the corresponding Swift code.
 *
 * Usage:
 * ```kotlin
 * swiftify {
 *     analysisMode(AnalysisMode.KSP)
 * }
 * ```
 */
abstract class SwiftifyProcessManifestTask : DefaultTask() {

    /**
     * The manifest files generated by KSP from all targets.
     * Auto-detected from build/generated/ksp/**/resources/swiftify-manifest.txt
     */
    @get:InputFiles
    @get:Optional
    abstract val manifestFiles: ListProperty<File>

    /**
     * Output directory for generated Swift files.
     */
    @get:OutputDirectory
    abstract val outputDirectory: DirectoryProperty

    private val enumGenerator = SwiftEnumGenerator()
    private val defaultsGenerator = SwiftDefaultsGenerator()
    private val asyncStreamGenerator = SwiftAsyncStreamGenerator()

    init {
        group = "swiftify"
        description = "Process KSP manifest and generate Swift code"
    }

    @TaskAction
    fun processManifest() {
        val manifests = manifestFiles.getOrElse(emptyList()).filter { it.exists() }
        if (manifests.isEmpty()) {
            logger.lifecycle("Swiftify: No manifest files found. Ensure KSP is configured and has run.")
            return
        }

        val outputDir = outputDirectory.get().asFile
        outputDir.mkdirs()

        logger.lifecycle(
            "Swiftify: Processing ${manifests.size} manifest(s) from targets: " +
                manifests.joinToString { it.parentFile?.parentFile?.parentFile?.name ?: "unknown" },
        )

        // Merge all manifests
        val mergedContent = ManifestMerger().merge(manifests)

        if (mergedContent.isBlank()) {
            logger.lifecycle("Swiftify: All manifests are empty")
            return
        }

        val declarations = parseManifestContent(mergedContent)
        val swiftCode = generateSwiftCode(declarations)

        if (swiftCode.isNotBlank()) {
            val outputFile = File(outputDir, "Swiftify.swift")
            outputFile.writeText(buildSwiftFile(swiftCode))
            logger.lifecycle("Swiftify: Generated ${outputFile.absolutePath}")
        } else {
            logger.lifecycle("Swiftify: No declarations to transform")
        }
    }

    private fun parseManifestContent(content: String): List<ParsedDeclaration> {
        val declarations = mutableListOf<ParsedDeclaration>()
        var currentSection: MutableMap<String, String>? = null
        var currentType: String? = null
        var currentName: String? = null
        val subclasses = mutableListOf<Pair<String, Boolean>>()
        val parameters = mutableListOf<Pair<String, String>>()

        content.lines().forEach { line ->
            when {
                line.startsWith("[sealed:") -> {
                    saveCurrentDeclaration(currentType, currentSection, subclasses, parameters, declarations)
                    currentType = "sealed"
                    currentName = line.substringAfter("[sealed:").substringBefore("]")
                    currentSection = mutableMapOf("qualifiedName" to currentName!!)
                    subclasses.clear()
                }
                line.startsWith("[suspend:") -> {
                    saveCurrentDeclaration(currentType, currentSection, subclasses, parameters, declarations)
                    currentType = "suspend"
                    currentName = line.substringAfter("[suspend:").substringBefore("]")
                    currentSection = mutableMapOf("qualifiedName" to currentName!!)
                    parameters.clear()
                }
                line.startsWith("[flow:") -> {
                    saveCurrentDeclaration(currentType, currentSection, subclasses, parameters, declarations)
                    currentType = "flow"
                    currentName = line.substringAfter("[flow:").substringBefore("]")
                    currentSection = mutableMapOf("qualifiedName" to currentName!!)
                    parameters.clear()
                }
                line.startsWith("subclass=") -> {
                    val parts = line.substringAfter("subclass=").split(":")
                    subclasses.add(parts[0] to (parts.getOrNull(1)?.toBooleanStrictOrNull() ?: false))
                }
                line.startsWith("param=") -> {
                    val parts = line.substringAfter("param=").split(":")
                    parameters.add(parts[0] to (parts.getOrNull(1) ?: "Any"))
                }
                line.contains("=") && currentSection != null -> {
                    val (key, value) = line.split("=", limit = 2)
                    currentSection!![key] = value
                }
            }
        }

        saveCurrentDeclaration(currentType, currentSection, subclasses, parameters, declarations)
        return declarations
    }

    private fun saveCurrentDeclaration(
        type: String?,
        section: Map<String, String>?,
        subclasses: List<Pair<String, Boolean>>,
        parameters: List<Pair<String, String>>,
        declarations: MutableList<ParsedDeclaration>,
    ) {
        if (type == null || section == null) return

        when (type) {
            "sealed" -> {
                val cases = subclasses.map { (name, isObject) ->
                    if (isObject) {
                        SwiftEnumCase(name.replaceFirstChar { it.lowercase() })
                    } else {
                        SwiftEnumCase(
                            name.replaceFirstChar { it.lowercase() },
                            listOf(SwiftEnumCase.AssociatedValue("value", SwiftType.Named(name))),
                        )
                    }
                }
                declarations.add(
                    ParsedDeclaration.SealedClass(
                        SwiftEnumSpec(
                            name = section["swiftName"] ?: section["name"] ?: "",
                            cases = cases,
                            isExhaustive = section["exhaustive"]?.toBooleanStrictOrNull() ?: true,
                        ),
                    ),
                )
            }
            "suspend" -> {
                val params = parameters.map { (name, typeName) ->
                    SwiftParameter(name, mapKotlinTypeToSwift(typeName))
                }
                declarations.add(
                    ParsedDeclaration.SuspendFunction(
                        SwiftDefaultsSpec(
                            name = section["name"] ?: "",
                            parameters = params,
                            returnType = mapKotlinTypeToSwift(section["return"] ?: "Unit"),
                            isThrowing = section["throwing"]?.toBooleanStrictOrNull() ?: true,
                        ),
                    ),
                )
            }
            "flow" -> {
                val params = parameters.map { (name, typeName) ->
                    SwiftParameter(name, mapKotlinTypeToSwift(typeName))
                }
                declarations.add(
                    ParsedDeclaration.FlowFunction(
                        SwiftAsyncStreamSpec(
                            name = section["name"] ?: "",
                            parameters = params,
                            elementType = mapKotlinTypeToSwift(section["element"] ?: "Any"),
                        ),
                    ),
                )
            }
        }
    }

    private fun mapKotlinTypeToSwift(kotlinType: String): SwiftType = when (kotlinType) {
        "String" -> SwiftType.Named("String")
        "Int" -> SwiftType.Named("Int")
        "Long" -> SwiftType.Named("Int64")
        "Float" -> SwiftType.Named("Float")
        "Double" -> SwiftType.Named("Double")
        "Boolean" -> SwiftType.Named("Bool")
        "Unit" -> SwiftType.Void
        else -> SwiftType.Named(kotlinType)
    }

    private fun generateSwiftCode(declarations: List<ParsedDeclaration>): String = declarations.joinToString("\n\n") { decl ->
        when (decl) {
            is ParsedDeclaration.SealedClass -> enumGenerator.generate(decl.spec)
            is ParsedDeclaration.SuspendFunction -> defaultsGenerator.generate(decl.spec)
            is ParsedDeclaration.FlowFunction -> asyncStreamGenerator.generate(decl.spec)
        }
    }

    private fun buildSwiftFile(content: String): String = """
        |// Generated by Swiftify (KSP mode)
        |// Do not edit - this file is auto-generated
        |
        |import Foundation
        |
        |$content
    """.trimMargin()

    private sealed class ParsedDeclaration {
        data class SealedClass(val spec: SwiftEnumSpec) : ParsedDeclaration()
        data class SuspendFunction(val spec: SwiftDefaultsSpec) : ParsedDeclaration()
        data class FlowFunction(val spec: SwiftAsyncStreamSpec) : ParsedDeclaration()
    }
}
