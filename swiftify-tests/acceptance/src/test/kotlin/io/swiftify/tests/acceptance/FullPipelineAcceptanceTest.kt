package io.swiftify.tests.acceptance

import io.swiftify.generator.SwiftifyTransformer
import org.junit.jupiter.api.Test
import kotlin.test.assertContains
import kotlin.test.assertTrue

/**
 * Full end-to-end pipeline test using realistic sample code.
 */
class FullPipelineAcceptanceTest {

    private val transformer = SwiftifyTransformer()

    @Test
    fun `full UserRepository transforms correctly`() {
        val kotlinSource = """
            package com.example

            import kotlinx.coroutines.flow.Flow
            import kotlinx.coroutines.flow.StateFlow
            import kotlinx.coroutines.flow.MutableStateFlow

            class UserRepository {
                private val _currentUser = MutableStateFlow<User?>(null)

                val currentUser: StateFlow<User?> = _currentUser

                suspend fun fetchUser(id: String): User {
                    return User(id = id, name = "John Doe", email = "john@example.com")
                }

                suspend fun fetchUserWithOptions(
                    id: String,
                    includeProfile: Boolean = true,
                    limit: Int = 10
                ): User {
                    return User(id = id, name = "John", email = "john@example.com")
                }

                fun getUserUpdates(userId: String): Flow<User> {
                    throw NotImplementedError("Stub")
                }

                suspend fun login(username: String, password: String): NetworkResult<User> {
                    return NetworkResult.Success(User("1", username, "${'$'}username@example.com"))
                }

                suspend fun logout() {
                    _currentUser.value = null
                }
            }

            data class User(
                val id: String,
                val name: String,
                val email: String
            )
        """.trimIndent()

        val result = transformer.transform(kotlinSource)

        println("=== Generated Swift Code ===")
        println(result.swiftCode)
        println("=== End ===")

        assertTrue(result.declarationsTransformed >= 4, "Should transform at least 4 declarations")

        // Check suspend functions are transformed
        assertContains(result.swiftCode, "func fetchUser")
        assertContains(result.swiftCode, "async")

        // Check Flow functions are transformed
        assertContains(result.swiftCode, "func getUserUpdates")
        assertContains(result.swiftCode, "AsyncStream")
    }

    @Test
    fun `full NetworkResult sealed class transforms correctly`() {
        val kotlinSource = """
            package com.example

            sealed class NetworkResult<out T> {
                data class Success<T>(val data: T) : NetworkResult<T>()
                data class Error(val message: String, val code: Int) : NetworkResult<Nothing>()
                data object Loading : NetworkResult<Nothing>()
            }

            sealed class AuthState {
                data object LoggedOut : AuthState()
                data class LoggedIn(val userId: String, val token: String) : AuthState()
                data class Error(val reason: String) : AuthState()
            }
        """.trimIndent()

        val result = transformer.transform(kotlinSource)

        println("=== Generated Swift Code ===")
        println(result.swiftCode)
        println("=== End ===")

        assertTrue(result.declarationsTransformed >= 2, "Should transform at least 2 sealed classes")

        // Check NetworkResult enum
        assertContains(result.swiftCode, "enum NetworkResult")
        assertContains(result.swiftCode, "case success")
        assertContains(result.swiftCode, "case error")
        assertContains(result.swiftCode, "case loading")

        // Check AuthState enum
        assertContains(result.swiftCode, "enum AuthState")
        assertContains(result.swiftCode, "case loggedOut")
        assertContains(result.swiftCode, "case loggedIn")
    }

    @Test
    fun `combined file generates valid Swift`() {
        val kotlinSource1 = """
            sealed class Result<out T> {
                data class Success<T>(val value: T) : Result<T>()
                data class Failure(val error: String) : Result<Nothing>()
            }
        """.trimIndent()

        val kotlinSource2 = """
            suspend fun fetchData(id: Int): String {
                return "data"
            }
        """.trimIndent()

        val result1 = transformer.transform(kotlinSource1)
        val result2 = transformer.transform(kotlinSource2)

        // Generate combined Swift file
        val combinedSwift = buildString {
            appendLine("// Generated by Swiftify")
            appendLine("import Foundation")
            appendLine()
            appendLine("// MARK: - Result")
            appendLine(result1.swiftCode)
            appendLine()
            appendLine("// MARK: - Functions")
            appendLine(result2.swiftCode)
        }

        println("=== Combined Swift File ===")
        println(combinedSwift)
        println("=== End ===")

        assertContains(combinedSwift, "enum Result")
        assertContains(combinedSwift, "func fetchData")
        assertContains(combinedSwift, "import Foundation")
    }
}
